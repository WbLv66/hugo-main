---
title: 基于搜索的路径规划
subtitle:
date: 2025-02-10T10:54:22+08:00
slug: 32c5de7
draft: true
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 规划
categories:
  - 笔记
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRelated: false
hiddenFromFeed: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password: false
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->

{{< figure src="https://cdn.pixabay.com/photo/2024/05/09/08/07/ai-generated-8750163_1280.jpg">}}

# 基于搜索的路径规划

算法流程：

- 维护一个容器用来存储待访问的节点；维护一个数组用来标记已访问的节点；维护一个数组用来标记父节点
- 进行初始化
- 循环遍历容器：
  - 按照预设规则弹出容器中的节点，将这个节点标记为已访问
  - 如果弹出的节点是终点，则证明找出路径，结束
  - 扩展邻居节点
  - 将未访问过且非障碍物的节点按着某种顺序放入容器中，记录父节点
- 结束
## 1. 广度优先与深度优先

### 1.1 广度优先(BFS)

广度优先算法使用的容器为**队列(queue)**，遵循的规则是**先进先出**。

{{< figure src="基于搜索的路径规划/queue.png" caption="queue"height="400" width="auto" >}}

算法：



```python
def bfs(grid, start, end):
  visited = np.zeros_like(grid) # 存储已访问过的节点,访问过为1 
  parent = np.full_like(grid, None, dtype=object)  # 存储父节点，以便重建路径
  queue = deque([start]) # 创建一个队列，并将起始节点添加到队列中
```
          